within OpalRT.Electrical.Machine.SynchronousMachine;
model GENROU_SM_T1 "Detail synchronous machine model in ePHASORsim internal library (Please see ePHASORsim user manual for SM_T1)."
  constant Real pi = Modelica.Constants.pi;
  // standard parameters
  parameter String Device_id = "m39";
  parameter Real fn = 50;
  parameter Real P_gen = 1000;
  parameter Real Q_gen = 342.702;
  parameter Real Vt_abs = 1.03;
  parameter Real Vt_ang = -10.96;
  parameter Real SB = 1000;
  parameter Real H = 50;
  parameter Real D = 0;
  parameter Real xd = 0.2;
  parameter Real xq = 0.19;
  parameter Real xdp = 0.06;
  parameter Real xqp = 0.06;
  parameter Real xds = 0.02;
  parameter Real xqs(fixed = false);
  parameter Real xl = 0.03;
  parameter Real Ra(fixed = false);
  parameter Real Tdo_p = 7;
  parameter Real Tdo_s = 0.03;
  parameter Real Tqo_p = 0.7;
  parameter Real Tqo_s = 0.04;
  parameter Real ZSOURCE_RE = 0.01;
  parameter Real ex_status = 0;
  // states
  Real sfd(start = sfd0);
  Real sd1(start = sd10);
  Real sq1(start = sq10);
  Real sq2(start = sq10);
  // algebraic variables
  Real ifd(start = ifd0);
  Real id1(start = id10);
  Real iq1(start = iq10);
  Real iq2(start = iq20);
  Real Te(start = Te0);
  Real i_d(start = i_d0);
  Real i_q(start = i_q0);
  Real saai_ad(start = saai_ad0);
  Real saai_aq(start = saai_aq0);
  Real u5(start = u50);
  Real u6(start = u60);
  Real Ed_sec(start = Ed_sec0);
  Real Eq_sec(start = Eq_sec0);
  Real Imag, Iang;
  Real EFD;
  Modelica.Blocks.Interfaces.RealInput efd(start = efd0) annotation(Placement(visible = true, transformation(origin = {-100, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {-100, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput anglev(start = Vt_ang) annotation(Placement(visible = true, transformation(origin = {100, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {100, 40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput v(start = Vt_abs) annotation(Placement(visible = true, transformation(origin = {100, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {100, 80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput delta(start = delta0) annotation(Placement(visible = true, transformation(origin = {100, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {100, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput slip(start = slip0) annotation(Placement(visible = true, transformation(origin = {100, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {100, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  OpalRT.NonElectrical.Connector.PwPin p annotation(Placement(visible = true, transformation(origin = {100, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {100, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealInput Tm(start = Tm0) annotation(Placement(visible = true, transformation(origin = {-100, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {-100, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput Tm_0 = Tm0 annotation(Placement(visible = true, transformation(origin = {-100, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180), iconTransformation(origin = {-100, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
  Modelica.Blocks.Interfaces.RealOutput efd_0 = if ex_status == 0 then efd0 else efd0_ex annotation(Placement(visible = true, transformation(origin = {-100, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 180), iconTransformation(origin = {-100, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
  Modelica.Blocks.Interfaces.RealOutput ETERM0 annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{-10, -10}, {10, 10}}, rotation = -90), iconTransformation(origin = {0, -100}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
protected
  parameter Real wR(fixed = false);
  parameter Real Rfd(fixed = false);
  parameter Real Rd1(fixed = false);
  parameter Real Rq1(fixed = false);
  parameter Real Rq2(fixed = false);
  parameter Real Lad(fixed = false);
  parameter Real Laq(fixed = false);
  parameter Real Lfd(fixed = false);
  parameter Real Ld1(fixed = false);
  parameter Real Lq1(fixed = false);
  parameter Real Lq2(fixed = false);
  parameter Real Lad_sec(fixed = false);
  parameter Real Laq_sec(fixed = false);
  // Initialization
  parameter Real P0(fixed = false);
  parameter Real Q0(fixed = false);
  parameter Real vr0(fixed = false);
  parameter Real vi0(fixed = false);
  parameter Real ir0(fixed = false);
  parameter Real ii0(fixed = false);
  parameter Real abs_i0(fixed = false);
  parameter Real phi0(fixed = false);
  parameter Real d1(fixed = false);
  parameter Real d2(fixed = false);
  parameter Real delta0(fixed = false);
  parameter Real Vt_d0(fixed = false);
  parameter Real Vt_q0(fixed = false);
  parameter Real i_d0(fixed = false);
  parameter Real i_q0(fixed = false);
  parameter Real ifd0(fixed = false);
  parameter Real efd0(fixed = false);
  parameter Real efd0_ex(fixed = false);
  parameter Real id10(fixed = false);
  parameter Real iq10(fixed = false);
  parameter Real iq20(fixed = false);
  parameter Real slip0(fixed = false);
  parameter Real sfd0(fixed = false);
  parameter Real sd10(fixed = false);
  parameter Real sq10(fixed = false);
  parameter Real sq20(fixed = false);
  parameter Real saai_ad0(fixed = false);
  parameter Real saai_aq0(fixed = false);
  parameter Real Ed_sec0(fixed = false);
  parameter Real Eq_sec0(fixed = false);
  parameter Real Te0(fixed = false);
  parameter Real Tm0(fixed = false);
  // From Kundur's paper and noteing that xds = xqs
  parameter Real u1(fixed = false);
  parameter Real u2(fixed = false);
  parameter Real u3(fixed = false);
  parameter Real u50(fixed = false);
  parameter Real u60(fixed = false);
initial equation
  // convert standard to fundamental parameters
  wR = fn * pi * 2;
  xqs = xds;
  Ra = ZSOURCE_RE;
  Rfd = (Lad + Lfd) / Tdo_p / wR;
  Rd1 = (Ld1 + Lad * Lfd / (Lad + Lfd)) / Tdo_s / wR;
  Rq1 = (Laq + Lq1) / Tqo_p / wR;
  Rq2 = (Lq2 + Laq * Lq1 / (Laq + Lq1)) / Tqo_s / wR;
  Lad = xd - xl;
  Laq = xq - xl;
  Lfd = Lad * (xdp - xl) / (Lad - xdp + xl);
  Ld1 = Lad * Lfd * (xds - xl) / (Lad * Lfd - (xds - xl) * (Lad + Lfd));
  Lq1 = Laq * (xqp - xl) / (Laq - xqp + xl);
  Lq2 = Laq * Lq1 * (xqs - xl) / (Laq * Lq1 - (xqs - xl) * (Laq + Lq1));
  Lad_sec = 1 / (1 / Lad + 1 / Lfd + 1 / Ld1);
  Laq_sec = 1 / (1 / Laq + 1 / Lq1 + 1 / Lq2);
  // Initialization
  P0 = P_gen / SB;
  Q0 = Q_gen / SB;
  vr0 = Vt_abs * cos(Vt_ang * pi / 180);
  vi0 = Vt_abs * sin(Vt_ang * pi / 180);
  ir0 = (P0 * vr0 + Q0 * vi0) / Vt_abs ^ 2;
  ii0 = (P0 * vi0 - Q0 * vr0) / Vt_abs ^ 2;
  abs_i0 = (ir0 ^ 2 + ii0 ^ 2) ^ 0.5;
  phi0 = atan2(Q0, P0);
  d1 = xq * abs_i0 * cos(phi0) - Ra * abs_i0 * sin(phi0);
  d2 = Vt_abs + Ra * abs_i0 * cos(phi0) + xq * abs_i0 * sin(phi0);
  delta0 = atan2(d1, d2) + Vt_ang * pi / 180;
  Vt_d0 = vr0 * sin(delta0) - vi0 * cos(delta0) "Initialitation";
  Vt_q0 = vr0 * cos(delta0) + vi0 * sin(delta0) "Initialitation";
  i_d0 = ir0 * sin(delta0) - ii0 * cos(delta0) "Initialitation";
  i_q0 = ir0 * cos(delta0) + ii0 * sin(delta0) "Initialitation";
  ifd0 = (Vt_q0 + Ra * i_q0 + xd * i_d0) / Lad;
  efd0 = Rfd * ifd0;
  efd0_ex = efd0 * Lad / Rfd;
  id10 = 0;
  iq10 = 0;
  iq20 = 0;
  slip0 = 0;
  sfd0 = (Lad + Lfd) * ifd0 - Lad * i_d0;
  sd10 = Lad * (ifd0 - i_d0);
  sq10 = -Laq * i_q0;
  sq20 = -Laq * i_q0;
  saai_ad0 = Lad_sec * ((-i_d0) + sfd0 / Lfd + sd10 / Ld1);
  saai_aq0 = Laq_sec * ((-i_q0) + sq10 / Lq1 + sq20 / Lq2);
  Ed_sec0 = Laq_sec * (sq10 / Lq1 + sq20 / Lq2);
  Eq_sec0 = Lad_sec * (sfd0 / Lfd + sd10 / Ld1);
  Te0 = -(saai_ad0 * i_q0 - saai_aq0 * i_d0);
  Tm0 = -Te0;
  // From Kundur's paper and noteing that xds = xqs
  u1 = -Ra;
  u2 = Lad_sec + xl;
  u3 = -u2;
  u50 = (-cos(delta0) * Ed_sec0) - sin(delta0) * Eq_sec0;
  u60 = cos(delta0) * Eq_sec0 - sin(delta0) * Ed_sec0;
  der(delta) = 0;
  der(slip) = 0;
  der(sfd) = 0;
  der(sd1) = 0;
  der(sq1) = 0;
  der(sq2) = 0;
equation
  EFD = if ex_status == 0 then efd else efd * Rfd / Lad;
  // derivatives equations
  der(delta) = wR * slip;
  der(slip) = 0.5 / H * (Te + Tm);
  der(sfd) = wR * (EFD - Rfd * ifd);
  der(sd1) = -wR * Rd1 * id1;
  der(sq1) = -wR * Rq1 * iq1;
  der(sq2) = -wR * Rq2 * iq2;
  // Algebraic equations
  [p.ir; p.ii] = [sin(delta), cos(delta); -cos(delta), sin(delta)] * [i_d; i_q] "convert ir ii to rotor reference";
  v = sqrt(p.vr ^ 2 + p.vi ^ 2);
  anglev = atan2(p.vi, p.vr) / pi * 180;
  Imag = sqrt(p.ii ^ 2 + p.ir ^ 2);
  Iang = atan2(p.ii, p.ir) / pi * 180;
  -p.vi = (-p.ii * u1) + p.ir * u2 + u5 "find terminal voltage from internal voltage u6-ju5 in network reference";
  p.vr = (-p.ii * u3) + p.ir * u1 + u6 "find terminal voltage from internal voltage u6-ju5 in network reference";
  u5 = (-cos(delta) * Ed_sec) - sin(delta) * Eq_sec "convert internal voltage in rotor ref to network ref";
  u6 = cos(delta) * Eq_sec - sin(delta) * Ed_sec "convert internal voltage in rotor ref to network ref";
  Ed_sec = Laq_sec * (sq1 / Lq1 + sq2 / Lq2);
  Eq_sec = Lad_sec * (sfd / Lfd + sd1 / Ld1);
  saai_ad = Lad_sec * ((-i_d) + sfd / Lfd + sd1 / Ld1);
  saai_aq = Laq_sec * ((-i_q) + sq1 / Lq1 + sq2 / Lq2);
  ifd = (sfd - saai_ad) / Lfd;
  id1 = (sd1 - saai_ad) / Ld1;
  iq1 = (sq1 - saai_aq) / Lq1;
  iq2 = (sq2 - saai_aq) / Lq2;
  Te = -(saai_ad * i_q - saai_aq * i_d);
  ETERM0 = Vt_abs;
  annotation(Diagram(coordinateSystem(extent = {{-100, -100}, {100, 100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {2, 2})), Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {2, 2}), graphics={  Rectangle(origin = {0.282885, -0.424328}, extent = {{-99.8586, 100}, {99.8586, -100}}), Text(origin = {-1.41423, 32.3907}, extent = {{-49.22, 29}, {49.22, -29}}, textString = "GENROU"), Text(origin = {-9.98, 2.32}, fillColor = {0, 0, 255}, extent = {{-31.12, 11.18}, {49.22, -29}}, textString = "SM_T1")}), experiment(StartTime = 0, StopTime = 100, Tolerance = 1e-06, Interval = 0.01));
end GENROU_SM_T1;
